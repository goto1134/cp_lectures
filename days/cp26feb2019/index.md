# Бинарный поиск
   
# ![](/img/tree.png)

###### (с) МЭИ, АВТИ, ПМ, 26 февраля 2019 года


## Проблема

* Пусть у нас есть массив $a_1,a_2,\ldots,a_n$ из $ n $ элементов.

* Надо узнать есть ли элемент $ b $ в нём (а так же найти его индекс).

* Для поиска одного элемента потребуются $ O(N) $ операций - _хорошая асимптотика_.

* Но если надо найти M элементов, то у нас будет $ O(N*M) $. 
* А если $ M = N $ - это уже $ O(N^2) $ - **ПЛОХО**.



## Можно лучше!
* Пусть у нас элементы массива $a_i$ из $ n $ элементов отсортированы, т.е. `$ \forall i = 1..n : a_i \le a_{i+1} $`
* Тогда для поиска нужного элемента можно воспользоваться техникой бинарного поиска.
* Мы выбираем средний элемент, смотрим больше или меньше он искомого и, в соответствии с этим, продолжаем поиск на 
    оставшейся части массива. Либо приходим к тому, что мы нашли искомый элемент.
* __Примечание:__ здесь и далее используем быструю сортировку.
# ![](/img/binsearch.png)




## Бинарный поиск (псевдокод)

* Дано: массив $ a $ из $ n $ элементов.
* Надо найти элемент со значением $ b $.
* Алгоритм:
```python
def binarySearch(alist, item):
	    first = 0
	    last = len(alist)-1
	    found = False
	
	    while first<=last and not found:
	        midpoint = (first + last) // 2
	        if alist[midpoint] == item:
                found = True
	        else:
	            if item < alist[midpoint]:
	                last = midpoint-1
	            else:
	                first = midpoint+1
	
	    return found
```



## Асимптоматика
* Сложность сортировки массива в памяти предполагаем в среднем случае $ O(N log_2 N) $, в худшем $ O(N^2) $. 
* Дополнительная память для самого поиска не требуется. Для сортировки $ O(N) $.
* Поиск одного элемента $ O(\log_2 N) $, т.к. массив каждый раз делится на 2 части.
* Итого поиск $ M $ элементов в среднем случае `$ O(\max (N, M) * \log_2 N) $` в худшем $ O(max(N,M)∗N) $. Затраты памяти $ O(N) $



## Область применения
* Алгоритм выгодно применять на больших массивах, которые выгружены в память в случаях, когда требуется провести много итераций поиска.
* Для остальных случаев можно применять линейный поиск за $ O(N) $.
* Для потоковых данных - линейный поиск.
* Для небольших массивов - линейный поиск.
* Так же бинарный поиск может встречаться во многих задачах СП (особенно итеративных).


## Бинарный поиск (C)
```cpp
int binary_find(int n, int *x, long A)
{
    int m, left, right;
    left = 0; right = n-1;
    while (true)
    {
        if (left > right) return (-1); // значение не найдено
        m = left + (right - left) / 2;
        if (x[m] < A) left = m + 1;
        if (x[m] > A) right = m - 1;
        if (x[m] == A) return m;
    }
}
```


## Бинарный поиск (C++11)
```cpp
#include <iostream>
#include <algorithm>
#include <vector>

int main()
{
    std::vector<int> haystack {1, 3, 4, 5, 9};
    std::vector<int> needles {1, 2, 3};

    for (auto needle : needles) {
        std::cout << "Searching for " << needle << '\n';
        if (std::binary_search(haystack.begin(), haystack.end(), needle)) {
            std::cout << "Found " << needle << '\n';
        } else {
            std::cout << "no dice!\n";
        }
    }
}
```


### Бинарный поиск (C++11, с индексом)
```cpp
#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>
 
template<class ForwardIt, class T, class Compare=std::less<>>
ForwardIt binary_find(ForwardIt first, ForwardIt last, const T& value,
    Compare comp={}) {
    first = std::lower_bound(first, last, value, comp);
    return first != last && !comp(value, *first) ? first : last;
}
int main() {
    std::vector<int> data = { 1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6 };
    auto it = binary_find(data.cbegin(), data.cend(), 4);
    if(it != data.cend())
      std::cout << *it << " found at index "<< std::distance(data.cbegin(), it);
    return 0;
}
```


## Бинарное дерево поиска
* Элементы массива можно представить в виде дерева.
# ![](/img/btree.png)



## Идея и свойства
* Слева от каждого узла располагаются элементы меньше его, справа - элементы больше него.
* У каждого узла не более двух детей.
* Любое значение меньше значения узла становится левым ребенком или ребенком левого ребенка.
* Любое значение больше или равное значению узла становится правым ребенком или ребенком правого ребенка.



## Добавление элемента
* Дано: дерево $ Т $ и число $ K $;
* Задача: вставить число в дерево $ Т $;
* Алгоритм:
    * Если дерево пусто, заменить его на дерево с одним корневым узлом _($K$, null, null)_ и остановиться.
    * Иначе сравнить $K$ с ключом корневого узла $X$:
        * Если $K>X$, рекурсивно добавить $K$ в правое поддерево $Т$;
        * Если $K<X$, рекурсивно добавить $K$ в левое поддерево $Т$;
        * Если $K=X$, значит текущее число уже есть в дереве.



## Удаление узлов
* Дано: дерево $Т$ с корнем $n$ и ключом $K$.
* Задача: удалить из дерева $Т$ узел с ключом $K$ (если такой есть).
* Алгоритм:
    * Если дерево $T$ пусто, остановиться;
    * Иначе сравнить $K$ с ключом $X$ корневого узла $n$.
        * Если $K>X$, рекурсивно удалить $K$ из правого поддерева $Т$;
        * Если $K<X$, рекурсивно удалить $K$ из левого поддерева $Т$;
        * Если $K=X$, то узел, который надо удалить, найден.



## Удаление узлов
* Если обоих детей нет, то удаляем текущий узел и обнуляем ссылку на него у родительского узла;
* Если одного из детей нет, то замещаем текущий узел существующем ребёнком;
* Если оба ребёнка присутствуют, то:
    * Если левый узел m правого поддерева отсутствует, то копируем из правого узла в удаляемый $ К $ и ссылку на правый узел правого потомка;
* Иначе:
    * Возьмём самый левый узел $m$, правого поддерева $n$;
    * Скопируем данные (кроме ссылок на дочерние элементы) из $m$ в $n$;
    * Рекурсивно удалим узел $m$.


## Поиск элемента
* Дано: дерево $Т$ и ключ $K$.
* Задача: проверить, есть ли узел с ключом $K$ в дереве $Т$, и если да, то вернуть ссылку на этот узел.
* Алгоритм:
    * Если дерево пусто, сообщить, что узел не найден, и остановиться.
    * Иначе сравнить $K$ со значением ключа корневого узла $X$.
        * Если $K=X$, выдать ссылку на этот узел и остановиться.
        * Если $K>X$, рекурсивно искать ключ $K$ в правом поддереве $Т$.
        * Если $K<X$, рекурсивно искать ключ K в левом поддереве $Т$.


## Обход дерева
* Дерево можно обходить тремя основными способами.
* Эти способы отличаются тем, когда используется значение для текущей вершины.
    * Инфиксный - сперва обрабатывается левое поддерево, потом значение в вершине, потом правое поддерево.
    * Префиксный - сперва обрабатывается значение в вершине, потом левое поддерево, потом правое поддерево.
    * Постфиксный - сперва обрабатывается левое поддерево, потом правое поддерево, потом значение в вершине.
* Функции обхода рекурсивны.


## Сложность и память
* Дерево можно реализовать как и указателями, так и при помощи массива.
* В случае, если дерево полное, то его высота $\log_2 N$.
* Для дерева требуется $ O(N) $ памяти.
* Сложность операций средняя - $ O(\log_2N) $, в худшем случае $ O(N) $.
* Худший случай - это построение дерева на отсортированном массиве.


## Деревативы
* Однородный двоичный поиск
* Троичный поиск
* Интерполирующий поиск
* Дробный спуск


## Однородный двоичный поиск
* Идея - на каждом этапе у нас интервал поиска снижается в 2 раза.
* Следовательно, мы можем хранить только опорное значение и длину интервала.
* За исключением этого алгоритм аналогичен обычному бинарному поиску.
```python
def binarySearch(alist, item):
        i = len(alist) / 2
        h = len(alist)
	    found = False
	
	    while h != 0 and not found:
	        if alist[i] == item:
                found = True
	        else:
	            if item < alist[i]:
	                i = i - h / 2 
	            else:
	                i = i + h / 2
            h = h / 2
	
	    return found
```

## Троичный (тернарный) поиск
* Аналогично двоичному, но с использованием трёх отрезков.
* Границы можно выбирать равномерно, а можно с использованием чисел Фибоначчи.


## Интерполирующий поиск
* Оценка расположение элемента производится на основе расстояния между текущим и искомым элементом.


## Дробный спуск
* Аналогично интерполяционому поиску, только дополнительно ещё ускоряем поиск в зависимости от разницы элементов.


## Поиск корней уравнения (дихотомия)
* Дихотомия, либо троичный. 



## Поиск корней уравнения (троичный)
* https://e-maxx.ru/algo/ternary_search
* Беруться две точки (отрезок делится на 3 части)
* Выбирается отрезок, на котром значение функции 
```cpp
 // входные данные
double l = ..., r = ..., EPS = ...;
while (r - l > EPS) {
   double m1 = l + (r - l) / 3,
      m2 = r - (r - l) / 3;
   if (f (m1) < f (m2))
      l = m1;
   else
      r = m2;
}
```


## Интерактивные задачи
* Интерактивная задача - задача в которой 


## Пример №1. Два торта.
https://codeforces.com/problemset/problem/911/B
* ограничение по времени на тест: _1 секунда_
* ограничение по памяти на тест: _256 мегабайт_
* ввод: _стандартный ввод_
* вывод: _стандартный вывод_

В самый канун Нового года Иван решил приступить к оформлению праздничного стола. Иван купил два торта и разрезал их на части: первый торт был разрезан на a кусков, а второй — на b кусков.
Иван знает, что на празднование соберется n человек (включая его самого), так что он должен разложить n тарелок для торта. Теперь его задача — распределить торты по тарелкам.


## Пример №1. Два торта.
Иван хочет это сделать таким образом, чтобы выполнялись следующие условия:
1. каждый кусок торта лежит на какой-либо тарелке;
2. на каждой тарелке лежит хотя бы один кусок торта;
3. ни на одной тарелке не лежат куски обоих тортов.

Чтобы сделать гостей чуточку счастливее, Иван хочет распределить торты так, чтобы минимальное количество кусков торта на тарелке было максимально. 
Формально, Иван хочет знать такое максимальное число $x$, что он может распределить торты по тарелкам, соблюдая все вышеприведенные условия, и на каждой тарелке будет хотя бы $x$ кусков торта. Надо найти число $x$.



## Пример №1. Два торта.
Решение. Математика



## Пример №1. Два торта.
Решение. Код.



## Пример №2. (Петрозаводск)



## Пример №3. Сахир и нубийский рынок.
https://codeforces.com/contest/812/problem/C



## Пример №4. Про таблицу умножения
https://codeforces.com/contest/448/problem/D 



## Пример №5. Черви
https://codeforces.com/contest/474/problem/B


## Ссылкота

1. http://algowiki-project.org/ru/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA
2. https://en.cppreference.com/w/cpp/algorithm/binary_search
3. https://medium.freecodecamp.org/data-structures-101-binary-search-tree-398267b6bff0
4. https://tproger.ru/translations/binary-search-tree-for-beginners/
5. https://life-prog.ru/view_manyart.php?id=2149&page=42
6. https://codeforces.com/blog/entry/45307?locale=ru
7. 