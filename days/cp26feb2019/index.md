# Бинарный поиск
   
# ![](/img/tree.png)

###### (с) МЭИ, АВТИ, ПМ, 26 февраля 2019 года


## Схема презентации
<section id="toc">
<a href="#/binary-tree">Бинарный поиск</a> </br>
<a href="#/binary-tree">Бинарное дерево</a> </br>
<a href="#/derivatives">Деривативы</a> </br>
<a href="#/applications">Важные применения</a> </br>
<a href="#/example-1">Пример 1</a> </br>
<a href="#/example-2">Пример 2</a> </br>
<a href="#/example-3">Пример 3</a> </br>
<a href="#/example-4">Пример 4</a> </br>
<a href="#/example-5">Пример 5</a> </br>
<a href="#/tasks">Задачи и ссылки</a> </br>


## Проблема

* Пусть у нас есть массив $a_1,a_2,\ldots,a_n$ из $ n $ элементов.

* Надо узнать есть ли элемент $ b $ в нём (а так же найти его индекс).

* Для поиска одного элемента потребуются $ O(N) $ операций - _хорошо!_

* Но если надо найти M элементов, то у нас будет $ O(N*M) $. 

* А если $ M = N $ - это уже $ O(N^2) $ - **плохо**.


## Сложности алгоритмов

<table style="font-size: 0.7em !important;">
    <thead>
        <tr>
            <th>$N$</th>
            <th>Сложность</th>
            <th>$N = 10$</th>
            <th>$N = 100$</th>
            <th>$N = 1000$</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>$n \le 10$</td>
            <td>$O(n!)$</td>
            <td>3628800</td>
            <td>`$9*10^{157}$`</td>
            <td>`$4*10^{2567}$`</td>
        </tr>
        <tr>
            <td>$n \le 20$</td>
            <td>$O(2^n)$</td>
            <td>$1024$</td>
            <td>$10^{30}$</td>
            <td>$10^{301}$</td>
        </tr>
        <tr>
            <td>$n \le 500$</td>
            <td>$O(n^3)$</td>
            <td>$1000$</td>
            <td>$1000000$</td>
            <td>$1000000000$</td>
        </tr>
        <tr>
            <td>$n \le 5000$</td>
            <td>$O(n^2)$</td>
            <td>$100$</td>
            <td>$10000$</td>
            <td>$1000000$</td>
        </tr>
        <tr>
            <td>$n \le 10^6$</td>
            <td>$O(n\log_2n)$</td>
            <td>$33$</td>
            <td>$664$</td>
            <td>$9966$</td>
        </tr>
        <tr>
            <td>$n \le 10^9$</td>
            <td>$O(n)$</td>
            <td>$10$</td>
            <td>$100$</td>
            <td>$1000$</td>
        </tr>
        <tr>
            <td>$n > 10^9$</td>
            <td>$O(\log_2 n)$</td>
            <td>$3$</td>
            <td>$7$</td>
            <td>$10$</td>
        </tr>
        <tr>
            <td>$n >> 10^9$</td>
            <td>$O(1)$</td>
            <td>$1$</td>
            <td>$1$</td>
            <td>$1$</td>
        </tr>
    </tbody>
</table>


## Можно лучше!
* Пусть у нас элементы массива $a_i$ из $ n $ элементов отсортированы, т.е. `$ \forall i = 1..n : a_i \le a_{i+1} $`
* Тогда для поиска нужного элемента можно воспользоваться техникой бинарного поиска.
* Мы выбираем средний элемент, смотрим больше или меньше он искомого и, в соответствии с этим, продолжаем поиск на 
    оставшейся части массива. Либо приходим к тому, что мы нашли искомый элемент.
* __Примечание:__ здесь и далее используем быструю сортировку, либо полагаем, что массив отсортирован в порядке возрастания элементов слева направо.
# ![](/img/binsearch.png)


## Бинарный поиск (псевдокод)
<section id="binary-search">
* Дано: массив $ a $ из $ n $ элементов.
* Надо найти элемент со значением $ b $.
* Алгоритм:
```python
def binarySearch(alist, item):
	    first = 0
	    last = len(alist)-1
	    found = False
	
	    while first<=last and not found:
	        midpoint = (first + last) // 2
	        if alist[midpoint] == item:
                found = True
	        else:
	            if item < alist[midpoint]:
	                last = midpoint-1
	            else:
	                first = midpoint+1
	
	    return found
```


## Затраты
* Сложность сортировки массива в памяти предполагаем в среднем случае $ O(N \log_2 N) $, в худшем $ O(N^2) $. 
* Дополнительная память для самого поиска не требуется. Для сортировки $ O(N) $.
* Поиск одного элемента $ O(\log_2 N) $, т.к. массив каждый раз делится на 2 части.
* Итого поиск $ M $ элементов в среднем случае `$ O(\max (N, M) * \log_2 N) $` в худшем $ O(max(N,M)∗N) $. Затраты памяти $ O(N) $.


## Область применения
* Алгоритм выгодно применять на больших массивах, которые выгружены в память в случаях, когда требуется провести много итераций поиска.
* Для остальных случаев можно применять линейный поиск за $ O(N) $.
* Для потоковых данных - линейный поиск.
* Для небольших массивов - линейный поиск.
* Так же бинарный поиск может встречаться во многих задачах СП (особенно итеративных).


## Бинарный поиск (C)
```cpp
int binary_find(int n, int *x, long A)
{
    int m, left, right;
    left = 0; right = n-1;
    while (true)
    {
        if (left > right) return (-1); // значение не найдено
        m = left + (right - left) / 2;
        if (x[m] < A) left = m + 1;
        if (x[m] > A) right = m - 1;
        if (x[m] == A) return m;
    }
}
```


## Бинарный поиск (C++11)
```cpp
#include <iostream>
#include <algorithm>
#include <vector>

int main()
{
    std::vector<int> haystack {1, 3, 4, 5, 9};
    std::vector<int> needles {1, 2, 3};

    for (auto needle : needles) {
        std::cout << "Searching for " << needle << '\n';
        if (std::binary_search(haystack.begin(), haystack.end(), needle)) {
            std::cout << "Found " << needle << '\n';
        } else {
            std::cout << "no dice!\n";
        }
    }
}
```


### Бинарный поиск (C++11, с индексом)
```cpp
#include <algorithm>
#include <iostream>
#include <iterator>
#include <vector>
 
template<class ForwardIt, class T, class Compare=std::less<>>
ForwardIt binary_find(ForwardIt first, ForwardIt last, const T& value,
    Compare comp={}) {
    first = std::lower_bound(first, last, value, comp);
    return first != last && !comp(value, *first) ? first : last;
}
int main() {
    std::vector<int> data = { 1, 1, 2, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6 };
    auto it = binary_find(data.cbegin(), data.cend(), 4);
    if(it != data.cend())
      std::cout << *it << " found at index "<< std::distance(data.cbegin(), it);
    return 0;
}
```


## Бинарное дерево поиска
<section id="binary-tree">
* Элементы массива можно представить в виде дерева.
# ![](/img/btree.png)


## Идея и свойства
* Слева от каждого узла располагаются элементы меньше его, справа - элементы больше него.
* У каждого узла не более двух детей.
* Любое значение меньше значения узла становится левым ребенком или ребенком левого ребенка.
* Любое значение больше или равное значению узла становится правым ребенком или ребенком правого ребенка.


## Добавление элемента
* Дано: дерево $ Т $ и число $ K $;
* Задача: вставить число в дерево $ Т $;
* Алгоритм:
    * Если дерево пусто, заменить его на дерево с одним корневым узлом $K$ и остановиться.
    * Иначе сравнить $K$ с ключом корневого узла $X$:
        * Если $K>X$, рекурсивно добавить $K$ в правое поддерево $Т$;
        * Если $K<X$, рекурсивно добавить $K$ в левое поддерево $Т$;


## Удаление узлов
* Дано: дерево $Т$ с корнем $n$ и ключом $K$.
* Задача: удалить из дерева $Т$ узел с ключом $K$ (если такой есть).
* Алгоритм:
    * Если дерево $T$ пусто, остановиться;
    * Иначе сравнить $K$ с ключом $X$ корневого узла $n$.
        * Если $K>X$, рекурсивно удалить $K$ из правого поддерева $Т$;
        * Если $K<X$, рекурсивно удалить $K$ из левого поддерева $Т$;
        * Если $K=X$, то узел, который надо удалить, найден.



## Удаление узлов
* Если обоих детей нет, то удаляем текущий узел и обнуляем ссылку на него у родительского узла;
* Если одного из детей нет, то замещаем текущий узел существующем ребёнком;
* Если оба ребёнка присутствуют, то:
    * Если левый узел m правого поддерева отсутствует, то копируем из правого узла в удаляемый $ К $ и ссылку на правый узел правого потомка;
* Иначе:
    * Возьмём самый левый узел $m$, правого поддерева $n$;
    * Скопируем данные (кроме ссылок на дочерние элементы) из $m$ в $n$;
    * Рекурсивно удалим узел $m$.



## Поиск элемента
* Дано: дерево $Т$ и ключ $K$.
* Задача: проверить, есть ли узел с ключом $K$ в дереве $Т$, и если да, то вернуть ссылку на этот узел.
* Алгоритм:
    * Если дерево пусто, сообщить, что узел не найден, и остановиться.
    * Иначе сравнить $K$ со значением ключа корневого узла $X$.
        * Если $K=X$, выдать ссылку на этот узел и остановиться.
        * Если $K>X$, рекурсивно искать ключ $K$ в правом поддереве $Т$.
        * Если $K<X$, рекурсивно искать ключ K в левом поддереве $Т$.



## Обход дерева
* Дерево можно обходить тремя основными способами.
* Эти способы отличаются тем, когда используется значение для текущей вершины.
    * Инфиксный - сперва обрабатывается левое поддерево, потом значение в вершине, потом правое поддерево.
    * Префиксный - сперва обрабатывается значение в вершине, потом левое поддерево, потом правое поддерево.
    * Постфиксный - сперва обрабатывается левое поддерево, потом правое поддерево, потом значение в вершине.
* Функции обхода рекурсивны.



## Сложность и память
* Дерево можно реализовать как и указателями, так и при помощи массива.
* В случае, если дерево полное, то его высота $\log_2 N$.
* Для дерева требуется $ O(N) $ памяти.
* Сложность операций средняя - $ O(\log_2N) $, в худшем случае $ O(N) $.
* Худший случай - это построение дерева на отсортированном массиве.



## Деривативы
<section id="derivatives">
* Однородный двоичный поиск
* Троичный поиск
* Интерполирующий поиск
* Экспоненциальный поиск


## Однородный двоичный поиск
* Идея - на каждом этапе у нас интервал поиска снижается в 2 раза.
* Следовательно, мы можем хранить только опорное значение и длину интервала.
* За исключением этого алгоритм аналогичен обычному бинарному поиску.
```python
def binarySearch(alist, item):
        i = len(alist) / 2
        h = len(alist)
	    found = False
	    while h != 0 and not found:
	        if alist[i] == item:
                found = True
	        else:
	            if item < alist[i]:
	                i = i - h / 2 
	            else:
	                i = i + h / 2
            h = h / 2
	    return found
```


## Троичный (тернарный) поиск
* Аналогично двоичному, но с использованием трёх отрезков.
* Границы можно выбирать равномерно, а можно с использованием чисел Фибоначчи.
* Сложность $O(\log_3 N) $.


## Троичный (тернарный) поиск
```cpp
int ternary_search(int *ar, int l,int r, int x) {
    if(r>=l) {
        int mid1 = l + (r-l)/3;
        int mid2 = r -  (r-l)/3;
        if(ar[mid1] == x)
            return mid1;
        if(ar[mid2] == x)
            return mid2;
        if(x<ar[mid1])
            return ternary_search(l,mid1-1,x);
        else if(x>ar[mid2])
            return ternary_search(mid2+1,r,x);
        else
            return ternary_search(mid1+1,mid2-1,x);
    }
    return -1;
}
```


## Интерполирующий поиск
* Оценка расположение элемента производится на основе расстояния между текущим и искомым элементом.
* Элемент, по которому делится отрезок, выбирается по следующей формуле:
$$ pos = l + \frac{(r-l)(x - a_l)}{(a_r - a_l)} $$
* Это позволяет получить сложность $ O(\log_2 \log_2 N) $.


## Интерполирующий поиск
```cpp
int interpolationSearch(int arr[], int n, int x) {  
    int lo = 0, hi = (n - 1); 
    while (lo <= hi && x >= arr[lo] && x <= arr[hi]) { 
        if (lo == hi) { 
            if (arr[lo] == x) return lo; 
            return -1; 
        } 
        int pos = lo + (((double)(hi - lo) / 
            (arr[hi] - arr[lo])) * (x - arr[lo])); 
        if (arr[pos] == x) 
            return pos; 
        if (arr[pos] < x) 
            lo = pos + 1; 
        else
            hi = pos - 1; 
    } 
    return -1; 
} 
```


## Экспоненциальный поиск
* Проходим массив слева направо, увеличивая шаг в геометрической прогрессии, пока текущий элемент не станет больше искомого.
* Запускам бинарный поиск на части массива между текущим шагом и прошлым. Сложность $ O(log_2i) $, где $ i $ - индекс искомого элемента.
```cpp
template <typename T>
int exponential_search(T arr[], int size, T key) {
    if (size == 0) {
        return NOT_FOUND;
    }
    int bound = 1;
    while (bound < size && arr[bound] < key) {
        bound *= 2;
    }
    return binary_search(arr, key, bound/2, min(bound + 1, size));
}
```


## Важные применения
<section id="applications">
* Поиск корней уравнения.
* Поиск минимумов и максимумов унимодальных функций.
* Решение интерактивных задач.


## Поиск корней уравнения (дихотомия)
* Дана функция $f(x)$, монотонная на отрезке $[a,b]$.
* Требуется найти $x \epsilon [a,b]$ такое что $f(x) = 0$ или сказать, что такого $x$ нет.
* Ищем середину отрезка $c= \frac{a + b}{2}$.
* Если $f(c) = 0$, то нашли корень.
* Иначе:
    * Если $f(a)*f(c) < 0$, то ищем корень на отрезке $[a, c]$.
    * Если $f(b)*f(c) < 0$, то ищем корень на отрезке $[c, b]$.
    * Иначе корней нет.


## Поиск корней уравнения (дихотомия)
```cpp
#define EPSILON 1e-5 
double func(double x) { 
    return x*x*x - x*x + 2; 
} 
double bisection(double a, double b) { 
    if (func(a) * func(b) >= 0) 
        return a - 10;
    double c = a; 
    while ((b-a) >= EPSILON) { 
        c = (a+b)/2; 
        if (func(c) == 0.0) 
            break; 
        else if (func(c)*func(a) < 0) 
            b = c; 
        else
            a = c; 
    } 
    return c;
} 
```


## Поиск максимума функции (троичный)
* Беруться две точки (отрезок делится на 3 части)
* Выбирается отрезок, которому принадлежит точка, в которой находится большее значение. 
```cpp
 // входные данные
double l = ..., r = ..., EPS = ...;
while (r - l > EPS) {
   double m1 = l + (r - l) / 3,
      m2 = r - (r - l) / 3;
   if (f (m1) < f (m2))
      l = m1;
   else
      r = m2;
}
```


## Интерактивные задачи
* Интерактивная задача - задача, ввод которой определяется специальной программой интерактором, в зависимости от вывода вашей программы.
* При разработки алгоритмов надо использовать функции очищения буфера ввода-вывода.
* Часто при решении таких задач надо использовать бинарный поиск или его модификации.
* Ограничивается не только время выполнения, но и количество пар запрос-ответ.
* Оценить подходит ли ваш алгоритм можно по количеству запросов, которые вы собираетесь совершить. К примеру в случае бинарного поиска из $N$ элементов вы совершите примерно $\log_2 N$ запросов.


## Пример №1. Отгадай число.
<section id="example-1">
https://codeforces.com/gym/101021/problem/A
* ограничение по времени на тест: _1.0 с_
* ограничение по памяти на тест: _256 МБ_
* ввод: _стандартный ввод_
* вывод: _стандартный вывод_

Эта задача немного необычна — в ней вам предстоит реализовать интерактивное взаимодействие с тестирующей системой. Это означает, что вы можете делать запросы и получать ответы в online-режиме. Обратите внимание, что ввод/вывод в этой задаче — стандартный (то есть с экрана на экран). После вывода очередного запроса обязательно используйте функции очистки потока, чтобы часть вашего вывода не осталась в каком-нибудь буфере. 


## Пример №1. Отгадай число.
Например, на С++ надо использовать функцию ```fflush(stdout)```, на Java вызов ```System.out.flush()```, на Pascal ```flush(output)``` и ```stdout.flush()``` для языка Python.

В этой задаче вам предстоит в интерактивном режиме угадать число x, которое загадала тестирующая система. Про загаданное число известно, что оно целое и лежит в границах от 1 до 1 000 000 включительно.

Вы можете делать запросы к тестирующей системе, каждый запрос — это вывод одного целого числа от 1 до 1 000 000.


## Пример №1. Отгадай число.
Есть два варианта ответа тестирующей системы на запрос:
* строка «<» (без кавычек), если загаданное число меньше числа из запроса;
* строка «>=» (без кавычек), если загаданное число больше либо равно числу из запроса.

В случае, если ваша программа считает, что определила загаданное число, выведите строку вида «! x», где x — это ответ, и завершите работу своей программы.

Вашей программе разрешается сделать не более 25 запросов (не считая вывода ответа).



## Пример №1. Отгадай число.
__Входные данные__

Для чтения ответов на запросы программа должна использовать стандартный ввод.

Входные данные будут содержать ответы на запросы, то есть строки вида «<» и «>=». i-я из этих строк является ответом системы на i-й запрос. После того, как ваша программа угадала число, выведите «! x» (без кавычек), где x — это ответ, и завершите работу своей программы.

Тестирующая система даст вашей программе прочитать ответ на запрос из входных данных только после того, как ваша программа вывела соответствующий запрос системе и выполнила операцию flush.


## Пример №1. Отгадай число.
__Выходные данные__

Для осуществления запросов программа должна использовать стандартный вывод.

Ваша программа должна выводить запросы — целые числа $x_i$ ($1 \le x_i \le 10^6$) по одному в строке. После вывода каждой строки программа должна выполнить операцию flush.

Каждое из значений $x_i$ обозначает очередной запрос к системе. Ответ на запрос программа сможет прочесть из стандартного ввода. В случае, если ваша программа угадала число, выведите строку вида «! x» (без кавычек), где x — ответ, и завершите работу программы.


## Пример №1. Отгадай число.
* При использовании бинарного поиска нам потребуется $\log_2 N$ запросов. При $N = 10^6$ это примерно $20$ запросов, что соответствует ограничениям.
* Следовательно, можем использовать бинарный поиск.


## Пример №1. Отгадай число.
```cpp
int main() {
    int l = 1, r = 1000000;
    while (l != r) {
        int mid = (l + r + 1) / 2;
        printf("%d\n", mid);
        fflush(stdout);

        char response[3];
        scanf("%s", response);
        if (strcmp(response, "<") == 0)
            r = mid - 1;
        else
            l = mid;
    }

    printf("! %d\n", l);
    fflush(stdout);
}
```


## Пример №2. Два торта.
<section id="example-2">
https://codeforces.com/problemset/problem/911/B
* ограничение по времени на тест: _1 секунда_
* ограничение по памяти на тест: _256 мегабайт_
* ввод: _стандартный ввод_
* вывод: _стандартный вывод_

В самый канун Нового года Иван решил приступить к оформлению праздничного стола. Иван купил два торта и разрезал их на части: первый торт был разрезан на a кусков, а второй — на b кусков.
Иван знает, что на празднование соберется n человек (включая его самого), так что он должен разложить $n$ тарелок для торта. Теперь его задача — распределить торты по тарелкам.



## Пример №2. Два торта.
Иван хочет это сделать таким образом, чтобы выполнялись следующие условия:
1. каждый кусок торта лежит на какой-либо тарелке;
2. на каждой тарелке лежит хотя бы один кусок торта;
3. ни на одной тарелке не лежат куски обоих тортов.

Чтобы сделать гостей чуточку счастливее, Иван хочет распределить торты так, чтобы минимальное количество кусков торта на тарелке было максимально. 
Формально, Иван хочет знать такое максимальное число $x$, что он может распределить торты по тарелкам, соблюдая все вышеприведенные условия, и на каждой тарелке будет хотя бы $x$ кусков торта. Надо найти число $x$.


## Пример №2. Два торта.
* Пусть мы возьмём $c$ кусочков первого торта и $d$ второго. Следовательно надо найти $$ x = \max_{c,d \epsilon [1; n-1]} \lfloor \min (\frac{a}{c}, \frac{b}{d}) \rfloor $$
* Тогда $c + d = n$ и из этого следует что $d = n - c$. Тогда  требуется найти максимум функции
`$$ x = \max_{c \epsilon [1; n-1]} \lfloor \min (\frac{a}{c}, \frac{b}{n - c}) \rfloor $$`
* Для этого надо воспользоваться тернарным поиском по $ n $.



## Пример №2. Два торта.
```cpp
dd f(dd a, dd b, dd n, dd x) {
	return min(a / x, b / (n - x));
}
int main() {
	ll n, a, b, x;
	cin >> n >> a >> b;
	dd l = 1, r = n - 1;
	while (r - l > 0.1) {
		dd m1 = l + (r - l) / 3, m2 = r - (r - l) / 3;
		if (m2 == r)
			m2--;
		if (f(a, b, n, m1) < f(a, b, n, m2))
			l = m1;
		else
			r = m2;
	}
	cout << floor(max(f(a, b, n, floor(l)), f(a, b, n, floor(l)+1)));
}
```


## Пример №2. Два торта.
* Так же можно обойтись без бинарного поиска, так как решение легко вывести аналитически.
* Пусть $a_s$ и $b_s$ части тортов при оптимальном распределении.
`$$ a_s = \frac{a*n}{a+b} $$`

`$$ b_s = \frac{b*n}{a+b} $$`

$$ x = \lfloor \max [\min(\frac{a}{\lceil a_s \rceil}, \frac{b}{\lfloor b_s \rfloor}), \min(\frac{a}{\lfloor a_s \rfloor}, \frac{b}{\lceil b_s \rceil})] \rfloor$$



## Пример №2. Два торта.
```cpp
int main() {
    double a, b, n, as, bs, ans;
    cin >> n >> a >> b;
    as = a * n / (a + b);
    bs = b * n / (a + b);
    if (as < 1) {
        ans = a;
    } else if (bs < 1) {
        ans = b;
    } else {
        ans = floor(max(min(a / ceil(as), b / floor(bs)), 
                    min(a / floor(as), b / ceil(bs))));
    }
    cout << ans << endl;
}
```


## Пример №3. Сахир и нубийский рынок.
<section id="example-3">
https://codeforces.com/contest/812/problem/C

* ограничение по времени на тест: _2 секунды_
* ограничение по памяти на тест: _256 мегабайт_
* ввод: _стандартный ввод_
* вывод: _стандартный вывод_

В поездке в Луксор и Асуан Сахир зашел на нубийский рынок, чтобы купить сувениров друзьям и родственникам. Он узнал, что на рынке действуют странные правила. На рынке имеются $n$ различных сувениров, пронумерованных от $1$ до $n$. 



## Пример №3. Сахир и нубийский рынок.
Сувенир номер $i$ имеет базовую стоимость $a_i$ Египетских фунтов. Если Сахир купит $k$ сувениров с индексами $x_1, x_2, ..., x_k$, то стоимость сувенира `$ x_j $` будет равна $a_{x_j} + x_j·k$ (для $1 ≤ j ≤ k$). Другими словами, стоимость сувенира равна его базовой стоимости плюс его номер, умноженный на $k$. 

Сахир хочет купить как можно больше сувениров, заплатив не более $S$ фунтов. Он не может купить никакой сувенир более, чем один раз. Он хочет минимизировать суммарную их стоимость. Помогите ему выбрать эти сувениры!


## Пример №3. Сахир и нубийский рынок.
__Входные данные__

Первая строка содержит два целых числа $n$ и $S$ ($1 ≤ n ≤ 10^5$, $1 ≤ S ≤ 10^9$) — количество сувениров и бюджет Сахира.

Вторая строка содержит n целых числе $a_1, a_2, ..., a_n$ ($1 ≤ ai ≤ 10^5$) — базовые стоимости сувениров.

__Выходные данные__
В единственной строке выведите два целых числа $k$ и $T$ — максимальное число сувениров, которое может купить Сахир, и минимальную стоимость покупки этих $k$ сувениров.


## Пример №3. Сахир и нубийский рынок.
* Если Сахир может купить $k$ товаров, то он может купить и меньше чем $k$ товаров, уместившись в бюджет.
* Если он не может купить $k$ товаров, то он не может купить не более чем $k$ товаров, т.к. он уже не влезает в бюджет.
* Задача может быть решена бинарным поиском относительно k:
    * Для каждого k считаем цены.
    * Сортируем цены.
    * Выбираем минимум k цен.


## Пример №3. Сахир и нубийский рынок.
```cpp
int n, S;
int a[N];
ll b[N];
 
ll res(int k)
{
    for (int i = 0; i < n; i++) {
        b[i] = a[i] + (i + 1) * (ll) k;
    }
    sort(b, b + n);
    ll ans = 0;
    for (int i = 0; i < k; i++) {
        ans += b[i];
    }
    return ans;
}
```


## Пример №3. Сахир и нубийский рынок.
```cpp
void solve(std::istream &in, std::ostream &out) {
    in >> n >> S;
    for (int i = 0; i < n; i++)
        in >> a[i];
    int l = 0, r = n + 1;
    while (l < r - 1) {
        int m = (l + r) / 2;
        if (res(m) <= S)
        {
            l = m;
        }
        else
        {
            r = m;
        }
    }
    out << l << ' ' << res(l) << '\n';
}
```


## Пример №4. Черви
<section id="example-4">
https://codeforces.com/contest/474/problem/B

* ограничение по времени на тест: _1 секунда_
* ограничение по памяти на тест: _256 мегабайт_
* ввод: _стандартный ввод_
* вывод: _стандартный вывод_

Пора Кроту пообедать. Его друг Сурок приготовил вкусный обед.

Сурок принес Кроту $n$ упорядоченных кучек червей, таких, что в $i$-ой кучке содержатся $a_i$ червей. Он пронумеровал всех этих червей последовательными целыми числами: черви в первой кучке пронумерованы числами от $1$ до $a_1$, черви во второй - от $a_1 + 1$ до $a_1 + a_2$ и т.д..


## Пример №4. Черви
Крот не может съесть всех червей (Сурок принёс их слишком много для того, чтобы съесть за один подход). К тому же, насколько мы знаем, Крот слепой — поэтому Сурок помогает ему, называ номера самых сочных червей. Сурок даст Кроту червяка, только если Крот правильно назовет кучку, в которой лежит червяк.

Крот просит вас ему помочь. Для всех сочных червей, которых назвал Сурок, подскажите Кроту правильные ответы.


## Пример №4. Черви
__Входные данные__

В первой строке записано единственное целое число $n$ ($1 ≤ n ≤ 10^5$), количество кучек.

Во второй строке записано n целых чисел $a_1, a_2, ..., a_n$ ($1 ≤ ai ≤ 10^3$, $a_1 + a_2 + ... + a_n ≤ 10^6$), где $a_i$ — количество червей в $i$-й кучке.

В третьей строке записано единственное целое число $m$ ($1 ≤ m ≤ 10^5$), количество сочных червей, названных Сурком.

В четвертой строке записано m целых чисел $q_1, q_2, ..., q_m$ ($1 ≤ q_i ≤ a_1 + a_2 + ... + a_n$) — номера сочных червей.



## Пример №4. Черви
__Выходные данные__

Выведите $m$ строк. В $i$-ой строке должно быть целое число — номер кучки, в которой лежит червяк под номером $q_i$.



## Пример №4. Черви
* Задачу можно решить двумя способами.
    1. Мы можем записать пары границ номеро в червей в каждой куче `$(a_i, a_{i+1})$` и далее для каждого `$ q_i $` для того чтобы найти $j$ такое что: $a_{j-1} < q_i$ и $a_j \ge q_i$. Решение имеет сложность $O(n + m*\log_2n)$.
    2. Мы можем предпосчитать индекс каждой кучки для каждого червя и получать ответ за $O(1)$. Это решение имеет сложность $O(n+m)$. 



## Пример №4. Черви
```cpp
int n, l, r, q, m, low, high, mid, cnt, pre = 0;
vector< pair< int, int > > arr( 1e5 + 5 );
int solve(void) {
	low = 1;
	high = n;
	while( low <= high ) {
		mid = ( low + high ) / 2;
		if( m < arr[ mid ].first )	{
			high = mid - 1;
		}
		else if( m > arr[ mid ].second ) {
			low = mid + 1;
		}
		else {
			return mid;
		}
	}
}
```


## Пример №4. Черви
```cpp
int main( void ) {
	ios :: sync_with_stdio( 0 );
	cin.tie( 0 );
	cin >> n;
	for( int i = 1; i <= n; ++i ) {
		cin >> cnt;
		l = pre + 1;
		r = cnt + l - 1;
		arr[ i ] = { l, r };
		pre = r;
	}
	cin >> q;
	for( int i = 1; i <= q; ++i ) {
		cin >> m;
		cout << solve() << "\n";
	}
	return 0;
}
```


## Пример №5. Про таблицу умножения
<section id="example-5">
https://codeforces.com/contest/448/problem/D 

* ограничение по времени на тест: _1 секунда_
* ограничение по памяти на тест: _256 мегабайт_
* ввод: _стандартный ввод_
* вывод: _стандартный вывод_

Бизон-Чемпион не только обаятельный, но и очень умный.

Пока одни учили обычную таблицу умножения, Бизон-Чемпион развлекался по-своему. Бизон-Чемпион рисовал таблицу умножения размера $n × m$, где элемент, стоящий на пересечении $i$-й строки и $j$-го столбца, равняется $i·j$ (строки и столбцы таблицы нумеруются, начиная от единицы). 


## Пример №5. Про таблицу умножения
Затем его спрашивали, какое число в этой таблице $k$-е по величине? Бизон-Чемпион отвечал всегда правильно и не задумываясь. Сможете ли вы повторить его успех?

Рассмотрим описанную таблицу умножения. Если выписать все $n*m$ чисел из этой таблицы в порядке неубывания, то число выписанное $k$-м называется $k$-м по величине.




## Пример №5. Про таблицу умножения

Воспользуемся бинарным поиском по ответу. Нам нужно найти такое максимальное $x$, что количество чисел из таблицы, меньших $x$, строго меньше $k$. Чтобы посчитать это количество для фиксированного $x$, просуммируем количество меньших чисел в каждой строке. В $i$-й строке их будет $\min (\frac{x-1}{i}, m)$. Тем самым итоговая сложность — $O(n\log(nm))$.



## Пример №5. Про таблицу умножения
```cpp
ll f(ll x, int n, int m){
    ll res = 0;
    --x;
    for(int i=1;i<=n;++i) res+=min((ll)m, x/i);
    return res;
}
```


## Пример №5. Про таблицу умножения
```cpp
int main(){
    int n, m;
    cin>>n>>m;
    ll k;
    cin>>k;
    ll l = 1, r = 1LL*n*m+1;
    while(l<r){
        ll x = (l+r) / 2;
        if(f(x,n,m) < k) 
            l = x+1; 
        else 
            r = x;
    }
    cout<<l-1<<endl;
    return 0;
}
```


## Важно
* Данная презентация доступна по адресу: http://icpc.appmat.ru/days/cp26feb2019/
* Замечания, обнаруженные ошибки, вы можете отправлять мне через github: https://github.com/siriusfreak/cp_lectures



## Задачи для решения в классе
<section id="tasks">
1. https://www.hackerrank.com/challenges/tree-preorder-traversal
2. https://www.hackerrank.com/challenges/tree-postorder-traversal
3. https://www.hackerrank.com/challenges/tree-height-of-a-binary-tree
4. https://www.hackerrank.com/challenges/tree-top-view
5. https://www.hackerrank.com/challenges/tree-level-order-traversal
6. https://www.hackerrank.com/challenges/binary-search-tree-insertion
7. https://www.hackerrank.com/challenges/tree-huffman-decoding
8. https://www.hackerrank.com/challenges/binary-search-tree-lowest-common-ancestor
9. https://www.hackerrank.com/challenges/swap-nodes-algo


# Задачи для решения дома
1. https://leetcode.com/problems/maximum-binary-tree/
2. https://leetcode.com/problems/unique-binary-search-trees/
3. https://leetcode.com/problems/search-a-2d-matrix-ii/
4. https://leetcode.com/problems/search-in-rotated-sorted-array/
5. https://leetcode.com/problems/word-search-ii/



## Ссылки

1. [Про бинарный поиск](http://algowiki-project.org/ru/%D0%94%D0%B2%D0%BE%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BF%D0%BE%D0%B8%D1%81%D0%BA)
2. [CPP Reference. Binary search](https://en.cppreference.com/w/cpp/algorithm/binary_search)
3. [Binary search trees](https://medium.freecodecamp.org/data-structures-101-binary-search-tree-398267b6bff0)
4. [Бинарные деревья для начинающих](https://tproger.ru/translations/binary-search-tree-for-beginners/)
5. [Однородный бинарный поиск](https://life-prog.ru/view_manyart.php?id=2149&page=42)
6. [Интерактивные задачи](https://codeforces.com/blog/entry/45307?locale=ru)
7. [Тернарный поиск](https://www.hackerearth.com/ru/practice/algorithms/searching/ternary-search/tutorial/)
8. [Тернарный поиск максимума](https://e-maxx.ru/algo/ternary_search)
9. [Интерполирующий поиск](https://www.geeksforgeeks.org/interpolation-search/)
10. [Экспоненциальный поиск](https://en.wikipedia.org/wiki/Exponential_search)
11. [Метод дихотомии](https://www.geeksforgeeks.org/program-for-bisection-method/)
